# Algorithm\_coding
---

> list

linked list, doubly linked list,

> tree

> graph

---

### Recursion (되부름, 재귀)

1. 되부름(recursion) - 재귀함수

2. 반복(루프 기반) - 반복문

> 스택

함수 호출이 어떻게 동작하는지 조금 더 깊이 파헤칠 시간!

함수 호출의 동작 과정을 이해한다면, 되부름 또한 따라가기가 더 쉬워지고 왜 루프 반복보다 되부름을 적용해야 알고리즘을 더 쉽게 작성할 수 있는지 통찰력을 갖추게 될 것.

함수가 사용하는 모든 정보는 _스택_ 이라는 내부 저장소에 저장된다. 스택에서는 접시를 스택 프레임이라 부른다. 함수가 호출되면 이 함수는 스택의 맨 위에 새로운 스택 프레임을 받는다. 이 스택 프레임에 앞으로 사용될 모든 지역 변수가 보관된다. 이 함수가 다른 함수를 호출하면 원래 스택 프레임 공간은 유지되고, 새로운 스택 프레임이 스택의 맨 위에 추가된다. 새로 호출되는 함수가 자신의 지역 변수를 보관할 수 있는 공간이 마련되는 것이다. 요컨대, 현재 실행 중인 함수가 항상 스택의 맨 위에 있는 스택 프레임을 사용하는 구조라 할 수 있다.

활성 스택은 항상 현재 실행 중인 함수와 연결된다. 따라서 항상 스택의 맨 위에 존재하게 된다. 

> 스택의 힘

되부름으로 얻는 핵심 가치는 함수 호출을 단일 스택 프레임으로 그치지 않고 스택 구조로 처리할 수 있다는데 있다. 되부름 알고리즘은 각 스택 프레임에 저장된 모든 정보를 다룰 수 있는 장점이 있다. 그 결과, 되부름 함수는 되부름 호출이 돌아올 때까지 기다리다 이전 지점으로 곧장 옮겨 간다. 이런 식으로 동작하도록 루프를 작성하기 위해서는 스택구조를 직접 구현해야 한다.

> 되부름의 단점

스택의 크기는 고정되어 있다. 다시 말해, 무한대로 되부름을 사용할 수 없다. 어느 시점에서는 새로운 스택이 현재 스택의 맨 위에 추가되지 못한다. 그럴 공간이 없다는 의미.

스택에 더 이상 남은 공간이 없을 때를 가리켜 스택 오버플로(stack overflow) 라 한다. 

> 성능

되부름이 진행되는 동안 수많은 함수 호출이 발생한다. 각 함수 호출은 스택 프레임을 따로 만들며 인수를 전달한다. 바로 이과정에서 루프로 처리할 때와는 비교되지 않을 부담이 생겨난다. 이 부담은 현대 컴퓨터에 미치는 영향이 대개 크지 않다. 하지만 함수 호출이 지나치게 자주 일어난다면 함수 호출에서 비롯되는 부담을 목격하게 될 수도 있다.

---

### Binary Tree (이진 트리)

이진 트리의 종류에는 여러가지가 있다.

정렬된 것이 BST(binary search tree).

완전 이진 트리, 포화 이진 트리


